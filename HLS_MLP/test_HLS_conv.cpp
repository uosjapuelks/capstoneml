
#include <stdio.h>
//#include "ap_axi_sdata.h" // ap_axis can also be used, but it will include all sideband signals which we don't need
#include "hls_stream.h"
//#include "ap_int.h"
//#include "params.h"

// Creating a custom structure which includes the data word and TLAST signal.
// ACLK, ARESETN, TREADY, TDATA, TVALID are essential signals for AXIS.
// TLAST is a sideband signal which is optional in AXIS.
// However, it is necessary for us since we connecting M_AXIS to AXI Stream FIFO / AXI DMA.
// So, we create a struct with data (TDATA) and last (TLAST). The rest of the essential AXIS signals are automatically dealt with by the HLS tool.
struct AXIS_wLAST{
	float data;
	bool last;
};

void myconv_HLS(hls::stream<AXIS_wLAST>& S_AXIS, hls::stream<AXIS_wLAST>& M_AXIS);

#define INPUT_LAYER 120
#define TEST_CASES 2
#define OUTPUT 4

//ap_uint<8> sum = 0; // using arbitrary precision

float test_input_memory [TEST_CASES][INPUT_LAYER] = {{0.49223906142857143, 0.4882671471428572, 0.4874453714285714, 0.4857866028571428, 0.4926195135714286, 0.4873388452857143, 0.48470612142857145, 0.492482612, 0.506757155, 0.49943726648571424, 0.5131183057142857, 0.49226955857142857, 0.47481444, 0.48598449857142856, 0.506757155, 0.5259014771428572, 0.5197229457142858, 0.4851931585714286, 0.49995449418571436, 0.5070765478571428, 0.4933766194285715, 0.4865741448571429, 0.49718113542857145, 0.4987638139285714, 0.49442666599999996, 0.49853554292857144, 0.5085185928571428, 0.5161884585714286, 0.513510079, 0.5210734571428571, 0.5235540014285714, 0.5328826728571429, 0.5126730857142857, 0.5006964698999999, 0.4917939028571429, 0.49518753071428573, 0.5044096771428571, 0.5077272151428571, 0.5131145314285714, 0.5061446581428571, 0.49447224000000006, 0.4883850148571428, 0.4878676005714286, 0.4856457642857143, 0.4887502485714286, 0.5063423292857143, 0.5054749, 0.5036030819999999, 0.5004833789285714, 0.5046226922857143, 0.5012747182857143, 0.49987465642142853, 0.5111512414285715, 0.5060684080000001, 0.49699844242857144, 0.4984441584285715, 0.49984422030000003, 0.5106642628571428, 0.49891590328571433, 0.49439613857142856, 0.5384054275000001, 0.52505775, 0.549343934375, 0.5477877062500001, 0.5260004687500001, 0.5369838687499999, 0.534559741875, 0.541517889375, 0.547308865, 0.5666869343750001, 0.591032975, 0.55289035, 0.53472434375, 0.51109656375, 0.500831424, 0.50717605875, 0.53250970625, 0.55517980625, 0.5451690462500001, 0.5725676875, 0.461680615, 0.467995321875, 0.46212952749999997, 0.48521861, 0.4567575375, 0.46394014375000003, 0.45473743125, 0.44761468125, 0.45017348124999995, 0.40522234375000005, 0.454931959375, 0.45511152499999996, 0.47236473749999996, 0.480250641875, 0.4747290125, 0.46498760624999996, 0.44153939375, 0.45394435, 0.44433761875, 0.42591722499999995, 0.471693241875, 0.490487724375, 0.507860650625, 0.517676878125, 0.4932859475, 0.4979247134375, 0.5020996026875, 0.5072920275, 0.5030872108125, 0.490652325625, 0.5407061037500001, 0.524934300625, 0.5200261875, 0.49163993375, 0.490831890625, 0.497535655625, 0.52988730625, 0.556552725, 0.5303212562499999, 0.5298124875},
		{0.5038665788571428, 0.49292479142857143, 0.47775238285714283, 0.4984337302857143, 0.5078080571428571, 0.49850982065714283, 0.5036078717142857, 0.4933052428571429, 0.4808873042857143, 0.501888303, 0.5066363385714285, 0.4991186154285714, 0.5020557015714285, 0.4965163267142857, 0.47863510142857146, 0.5007165120714285, 0.50544933, 0.4999556089085714, 0.5022991905714286, 0.4933966237142858, 0.500856134, 0.5003235017857143, 0.4961689705714286, 0.4991212748, 0.49837558971428575, 0.5001713211571429, 0.5012365855714286, 0.5006278630285714, 0.4960776622857143, 0.498740808, 0.49881689828571424, 0.5009474271428572, 0.5017692026285714, 0.5005213213857143, 0.49647331657142857, 0.49893864271428573, 0.4993038763428571, 0.5007343742857143, 0.5006735020428572, 0.49904516928571424, 0.4894623357142857, 0.48544476714285717, 0.5166570157142857, 0.5141003804285714, 0.5113915647142857, 0.5023824714285714, 0.4886253428571429, 0.48459255571428567, 0.5141612521428571, 0.5141612981428572, 0.5107524522857142, 0.5008150566428572, 0.4879557932857143, 0.4859774457142857, 0.5156831042857143, 0.5151961257142857, 0.51076767, 0.5002215521714286, 0.4875296871428571, 0.4877883942857143, 0.48689548687500006, 0.488062659375, 0.49332990375, 0.48210708375, 0.48692541437500003, 0.485084871875, 0.488212298125, 0.489573999375, 0.49162403499999996, 0.481553423125, 0.48709001562500004, 0.485578675, 0.487299508125, 0.4887509925, 0.48560860312500004, 0.48489034374999995, 0.48916997812499996, 0.484650921875, 0.487104979375, 0.489588963125, 0.458488658125, 0.44229786875, 0.4330203375, 0.4356539625, 0.43906569375000004, 0.4563189125, 0.46028430625, 0.44362963749999995, 0.4258527, 0.4407566, 0.43161374375, 0.455555760625, 0.45738133750000004, 0.44931586875, 0.41841570624999996, 0.44184895625, 0.43569884999999997, 0.4538199625, 0.458518585625, 0.4502286625, 0.51189993125, 0.50926630875, 0.514982465, 0.5047322891875, 0.50929623625, 0.50917652625, 0.5124835168749999, 0.5078297875, 0.5031012393750001, 0.506542904375, 0.509760113125, 0.509490765, 0.5123488431250001, 0.50923638125, 0.5075005850000001, 0.50401402875, 0.510179098125, 0.5100893156249999, 0.5120046775, 0.510029460625}};
float test_restult_expected_memory [TEST_CASES][OUTPUT] = {{0.}, {3.}};
//float test_restult_expected_memory [TEST_CASES][OUTPUT] = {{5.63542796, 0., 2.65119, 0.4064574}, {0., 0.91876486, 0., 4.43290832}};
float result_memory [TEST_CASES][OUTPUT];

hls::stream<AXIS_wLAST> S_AXIS;
hls::stream<AXIS_wLAST> M_AXIS;

int main()
{
	int success;
	AXIS_wLAST read_output, write_input;

	for (int test_cnt=0; test_cnt<TEST_CASES; test_cnt++){
		printf(" Transmitting Data for test case %d ... \r\n",test_cnt);

		for(int i=0;i<INPUT_LAYER;i++){
			write_input.data = test_input_memory[test_cnt][i];
			write_input.last=0;
			if (i==INPUT_LAYER-1){
				write_input.last=1;
			}
			S_AXIS.write(write_input);
		}

		myconv_HLS(S_AXIS, M_AXIS);

		printf(" Receiving data for test case %d ... \r\n", test_cnt);

		for(int i=0; i<1; i++){

			read_output = M_AXIS.read();
			result_memory[test_cnt][i]=read_output.data;
		}
	}
	success=1;

	printf(" Comparing data ... \r\n");
	for (int tcnt=0; tcnt< TEST_CASES; tcnt++){
		for(int i=0; i<1;i++){
			printf("Data Received: %f, %f ...\r\n",result_memory[tcnt][i], test_restult_expected_memory[tcnt][i]);
			success = success & (result_memory[tcnt][i] == test_restult_expected_memory[tcnt][i]);
		}
	}

/*
	for (int tcnt=0; tcnt< TEST_CASES; tcnt++){
		for(int i=0; i<OUTPUT;i++){
			printf("Data Received: %f, %f ...\r\n",result_memory[tcnt][i], test_restult_expected_memory[tcnt][i]);
			success = success & (result_memory[tcnt][i] == test_restult_expected_memory[tcnt][i]);
		}
	}
*/
	if (success!=1) {
		printf("Test Failed \r\n");
		return 1;
	}
	printf("Test Success\r\n");

	return 0;
}

