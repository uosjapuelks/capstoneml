
#include <stdio.h>
//#include "ap_axi_sdata.h" // ap_axis can also be used, but it will include all sideband signals which we don't need
#include "hls_stream.h"
//#include "ap_int.h"
//#include "params.h"

// Creating a custom structure which includes the data word and TLAST signal.
// ACLK, ARESETN, TREADY, TDATA, TVALID are essential signals for AXIS.
// TLAST is a sideband signal which is optional in AXIS.
// However, it is necessary for us since we connecting M_AXIS to AXI Stream FIFO / AXI DMA.
// So, we create a struct with data (TDATA) and last (TLAST). The rest of the essential AXIS signals are automatically dealt with by the HLS tool.
struct AXIS_wLAST{
	float data;
	bool last;
};

void myip_HLS(hls::stream<AXIS_wLAST>& S_AXIS, hls::stream<AXIS_wLAST>& M_AXIS);

#define INPUT_LAYER 120
#define TEST_CASES 2
#define OUTPUT 4

//ap_uint<8> sum = 0; // using arbitrary precision

float test_input_memory [TEST_CASES][INPUT_LAYER] = {{0.5078708314285714, 0.5002314667285714, 0.5084796571428571, 0.5075361371428572, 0.4915267348571429, 0.49038538000000004, 0.497416125, 0.4990292397142857, 0.49569648371428565, 0.499333601, 0.5079470251428572, 0.5062426018571428, 0.5076576948571428, 0.5060597985714286, 0.5044314657142857, 0.49811596957142856, 0.5020878841428571, 0.4995921216571429, 0.5029705318571428, 0.49912036167142854, 0.48996418999999997, 0.5011646192857142, 0.5061865802857143, 0.5172653300000001, 0.5229721028571429, 0.5221351114285714, 0.5129586185714287, 0.5053343685714285, 0.49726879514285716, 0.4913794048571428, 0.48885320571428564, 0.4839682085714286, 0.47692236285714285, 0.4813356, 0.4857944928571429, 0.5015147527142857, 0.510721681, 0.5220287014285715, 0.5268528271428571, 0.5276898214285715, 0.4912948457142858, 0.49791471442857144, 0.4994973930428571, 0.5092217351428571, 0.5154915771428572, 0.51798734, 0.5158263757142857, 0.5095108789999999, 0.5028910211428571, 0.49689510428571426, 0.4894534714285715, 0.4856033014285714, 0.4847967214285714, 0.4866533242857143, 0.4906861114285714, 0.4966211561428571, 0.49799078185714285, 0.5043823685714286, 0.5092978028571428, 0.5146393428571429, 0.501357026, 0.5056965165, 0.504529343125, 0.50693850875, 0.50729763875, 0.5020603228125, 0.50171615625, 0.4978854335625, 0.4906579375, 0.488323590625, 0.485585221875, 0.491750291875, 0.49106195875, 0.49775075968750004, 0.504140285375, 0.50720785625, 0.533723640625, 0.5278728100000001, 0.52420668875, 0.520690204375, 0.46584989125, 0.44846200625000004, 0.44684591874999996, 0.43445592499999997, 0.42511853750000006, 0.43421650625, 0.44717511875, 0.45482160125000004, 0.46893242500000004, 0.47427448937500005, 0.48175637, 0.474873039375, 0.47500771437499995, 0.4630965625, 0.45473181875, 0.463949495625, 0.45812859375, 0.45718587499999996, 0.460403085, 0.45561468125, 0.5323067606249999, 0.5439934562500001, 0.549844285625, 0.55796960625, 0.55374983125, 0.549724575, 0.5431854125, 0.539639001875, 0.52813186875, 0.529762920625, 0.521024084375, 0.530226796875, 0.525647884375, 0.54745008375, 0.5609922875, 0.5469413162500001, 0.5664391, 0.5764348874999999, 0.57046435, 0.56031891875},{ 0.4975735178571428, 0.49690392314285714, 0.49602127542857144, 0.49833442099999997, 0.5004345137571429, 0.5027020051428572, 0.49816702242857147, 0.4926124291428572, 0.4992627229, 0.5033411638571429, 0.5020324104285714, 0.49500166514285715, 0.5032955097142857, 0.5081957264285715, 0.5132024685714286, 0.5059738885714286, 0.5088044485714286, 0.5046651354285714, 0.502412862, 0.4981822402857143, 0.49538637785714285, 0.5081543328571428, 0.5064955638571428, 0.4905622514285714, 0.48569247142857136, 0.49917567552857145, 0.5142567762857143, 0.5102848614285714, 0.49097314000000003, 0.48764038342857147, 0.5022497242857143, 0.5175743142857142, 0.5004539928571429, 0.48484026, 0.49905393099999995, 0.5192787371428571, 0.5106348771428572, 0.4929819238571429, 0.4959494462857143, 0.5080478064285714, 0.4940907878571429, 0.49762137871428574, 0.5042564542857143, 0.5046673421428571, 0.4974235438571428, 0.4948364728571429, 0.4989301320714286, 0.5037086040000001, 0.5009236984285714, 0.4941820961428572, 0.49428862285714287, 0.5023085421428571, 0.502536813, 0.4949582177142857, 0.49573433857142857, 0.5030237911428571, 0.5066761264285714, 0.5015019847857143, 0.4990366585714286, 0.5015019847857143, 0.4410409125, 0.44886695625, 0.468828615625, 0.47500864875, 0.457351410625, 0.44151975624999995, 0.45064764625000003, 0.469083, 0.47628056875, 0.4549871375, 0.44451250625, 0.45209913124999995, 0.46594060937500004, 0.4701155, 0.44880709999999996, 0.44382417499999993, 0.4526079, 0.469980826875, 0.475188215, 0.45194949375000004, 0.46153752499999995, 0.465727376875, 0.45453448312500006, 0.458694410625, 0.45658451875, 0.4491176, 0.45261912375, 0.45688379375, 0.4646499875, 0.45882908375, 0.45103296249999997, 0.4612831375, 0.46976759125, 0.45971194375, 0.45236474, 0.4490427875, 0.4585597375, 0.46457516875, 0.46102875499999996, 0.45902361249999996, 0.48585269875000003, 0.484880055625, 0.518368951875, 0.5244143112499999, 0.516962358125, 0.4880823, 0.487902734375, 0.518009820625, 0.529816228125, 0.52092775375, 0.49110497999999997, 0.494112695375, 0.512188918125, 0.52837970875, 0.51353565625, 0.49129950874999995, 0.49510030374999997, 0.519117139375, 0.529681554375, 0.51257797625}};
float test_restult_expected_memory [TEST_CASES][OUTPUT] = {{-0.26638007, -0.95910484, 0.11699605, 0.3870539}, {-1.5542357, 1.6031312, -2.5738385, 1.5449789}};
float result_memory [TEST_CASES][OUTPUT];

hls::stream<AXIS_wLAST> S_AXIS;
hls::stream<AXIS_wLAST> M_AXIS;

int main()
{
	int success;
	AXIS_wLAST read_output, write_input;

	for (int test_cnt=0; test_cnt<TEST_CASES; test_cnt++){
		printf(" Transmitting Data for test case %d ... \r\n",test_cnt);

		for(int i=0;i<INPUT_LAYER;i++){
			write_input.data = test_input_memory[test_cnt][i];
			write_input.last=0;
			if (i==INPUT_LAYER-1){
				write_input.last=1;
			}
			S_AXIS.write(write_input);
		}

		myip_HLS(S_AXIS, M_AXIS);

		printf(" Receiving data for test case %d ... \r\n", test_cnt);

		for(int i=0; i<OUTPUT; i++){

			read_output = M_AXIS.read();
			result_memory[test_cnt][i]=read_output.data;
		}
	}
	success=1;

	printf(" Comparing data ... \r\n");
	for (int tcnt=0; tcnt< TEST_CASES; tcnt++){
		for(int i=0; i<OUTPUT;i++){
			printf("Data Received: %f, %f ...\r\n",result_memory[tcnt][i], test_restult_expected_memory[tcnt][i]);
			success = success & (result_memory[tcnt][i] == test_restult_expected_memory[tcnt][i]);
		}
	}

	if (success!=1) {
		printf("Test Failed \r\n");
		return 1;
	}
	printf("Test Success\r\n");

	return 0;
}

